<div>
    <a class="btn btn-sm btn-info"
       routerLink="/reactive/explanations">Home</a>
    <main role="main" class="container">
        <div class="jumbotron heading">
            <markdown>
                Why do we need to build _Reactive_ systems differently?
                ---
            </markdown>
            <p class="lead">
                <markdown>
                    Why do we need to adopt a new paradigm to get the most bang for our buck?
                    What does being _Reactive_ provide that traditional programming paradigms cannot?
                </markdown>
            </p>
        </div>
        <div>
            <markdown>
                Modern applications have the ability to reach huge numbers of concurrent users.
                Even though the capabilities of modern hardware have continued to improve,
                performance of modern software is still a key concern.

                There are at least two general programming paradigms that can improve a programâ€™s performance:

                1. <span style="font-weight: bold">Parallelize</span>: use more threads and more hardware resources.
                1. Seek more efficiency in how current resources are used.

                <span style="font-weight: bold">Multi-Threading</span>, is this how I get the most bang for the buck?

                Java developers have the ability to easily write programs using blocking multi-threaded code.
                This practice is fine until a performance bottleneck arises.
                A solution would be to introduce even more threads threads, running similar blocking code.
                Scaling in resource utilization can quickly introduce thread contention and concurrency problems.

                All of those new threads are just sitting there blocking and wasting resources that could be used to do useful
                work instead of sitting idle, waiting to continue to do work.

                To reiterate, when a thread is blocked, no work is being done by that thread.
                It will eventually have to be put back into context, so that it may get some CPU time maybe get some work done.
                So throwing more threads that need to will eventually wait and need to start up again will start to add up.
                There is a point be reached when spawning new threads to do work becomes hindering rather than helping.

                The OS scheduler, is going to let a thread get *N* amount of clock time, and then it is going to context switch (which can add up as more things need to be process).
                Which involves moving things out of the direct memory cache, loading up next context of the thread and then trying to process a threads work.

                The more threads that are in need of being processed, the more the context switching needs to happen.
                As more and more threads spin up, there is point where **thrashing** occurs.
                Which means that all work being done for the all of the clock cycles is just setting up thread context, not doing any work before tearing down for the next thread to be processed.

                So the <span style="font-weight: bold">parallelization</span> approach is not a silver bullet, one-size-fits-all solution.
                However, it is necessary in order to harness the full power of the hardware.

                Large number of performance bottle-necks, as mentioned above, occur when processes are waiting for input and output I/O.
                Whether it be a network call, reading from disk, or even a database query.

                There is a way to reach the past the point of diminishing returns when introducing concurrency and throwing more threads at a problem.
                The CPU can only do so many things at once, and adding more threads exacerbates the problem.

                Which means that the biggest bang for our buck would be having a few active threads that are always doing work.
            </markdown>

        </div>
        <div style="display: flex">
            <a style="margin-top: 1em;" class="btn btn-sm btn-info"
               routerLink="/reactive/explanations/what"><< Back</a>
            <div style="flex-grow: 1;"></div>
            <a style="margin-top: 1em;" class="btn btn-sm btn-info"
               routerLink="/reactive/explanations/how">Next >></a>
        </div>
    </main>
</div>
